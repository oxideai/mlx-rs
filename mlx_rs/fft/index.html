<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Fast Fourier Transform (FFT) and its inverse (IFFT) for one, two, and `N` dimensions."><title>mlx_rs::fft - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mlx_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mlx_rs/index.html">mlx_rs</a><span class="version">0.14.0</span></h2></div><h2 class="location"><a href="#">Module fft</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate mlx_rs</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">mlx_rs</a>::<wbr><a class="mod" href="#">fft</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/mlx_rs/fft/mod.rs.html#1-162">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Fast Fourier Transform (FFT) and its inverse (IFFT) for one, two, and <code>N</code> dimensions.</p>
<p>Like all other functions in <code>mlx-rs</code>, three variants are provided for each FFT function, plus
each variant has a version that uses the default <code>StreamOrDevice</code> or takes a user-specified
<code>StreamOrDevice</code>.</p>
<p>The difference are explained below using <code>fftn</code> as an example:</p>
<ol>
<li><code>fftn_unchecked</code>/<code>fftn_device_unchecked</code>: This function is simply a wrapper around the C API
and does not perform any checks on the input. It may panic or get an fatal error that cannot
be caught by the rust runtime if the input is invalid.</li>
<li><code>try_fftn</code>/<code>try_fftn_device</code>: This function performs checks on the input and returns a
<code>Result</code> instead of panicking.</li>
<li><code>fftn</code>/<code>fftn_device</code>: This function is a wrapper around <code>try_fftn</code> and unwraps the result. It
panics if the input is invalid.</li>
</ol>
<p>The functions that contains <code>device</code> in their name are meant to be used with a user-specified
<code>StreamOrDevice</code>. If you don’t care about the stream, you can use the functions without <code>device</code>
in their names. Please note that GPU device support is not yet implemented.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2><h3 id="one-dimension"><a class="doc-anchor" href="#one-dimension">§</a>One dimension</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mlx_rs::{Dtype, Array, StreamOrDevice, complex64, fft::<span class="kw-2">*</span>};

<span class="kw">let </span>src = [<span class="number">1.0f32</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>array = Array::from_slice(<span class="kw-2">&amp;</span>src[..], <span class="kw-2">&amp;</span>[<span class="number">4</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>fft_result = fft(<span class="kw-2">&amp;</span>array, <span class="number">4</span>, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(fft_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
    complex64::new(<span class="number">10.0</span>, <span class="number">0.0</span>),
    complex64::new(-<span class="number">2.0</span>, <span class="number">2.0</span>),
    complex64::new(-<span class="number">2.0</span>, <span class="number">0.0</span>),
    complex64::new(-<span class="number">2.0</span>, -<span class="number">2.0</span>),
];
<span class="macro">assert_eq!</span>(fft_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>ifft_result = ifft(<span class="kw-2">&amp;</span>fft_result, <span class="number">4</span>, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(ifft_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
   complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">2.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">3.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">4.0</span>, <span class="number">0.0</span>),
];
<span class="macro">assert_eq!</span>(ifft_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>rfft_result = rfft(<span class="kw-2">&amp;</span>array, <span class="number">4</span>, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(rfft_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
   complex64::new(<span class="number">10.0</span>, <span class="number">0.0</span>),
   complex64::new(-<span class="number">2.0</span>, <span class="number">2.0</span>),
   complex64::new(-<span class="number">2.0</span>, <span class="number">0.0</span>),
];
<span class="macro">assert_eq!</span>(rfft_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>irfft_result = irfft(<span class="kw-2">&amp;</span>rfft_result, <span class="number">4</span>, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(irfft_result.dtype(), Dtype::Float32);
<span class="macro">assert_eq!</span>(irfft_result.as_slice::&lt;f32&gt;(), <span class="kw-2">&amp;</span>src[..]);

<span class="comment">// The original array is not modified
</span><span class="kw">let </span>data: <span class="kw-2">&amp;</span>[f32] = array.as_slice();
<span class="macro">assert_eq!</span>(data, <span class="kw-2">&amp;</span>src[..]);</code></pre></div>
<h3 id="two-dimensions"><a class="doc-anchor" href="#two-dimensions">§</a>Two dimensions</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mlx_rs::{Dtype, Array, StreamOrDevice, complex64, fft::<span class="kw-2">*</span>};

<span class="kw">let </span>src = [<span class="number">1.0f32</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>array = Array::from_slice(<span class="kw-2">&amp;</span>src[..], <span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">2</span>]);

<span class="kw">let </span><span class="kw-2">mut </span>fft2_result = fft2(<span class="kw-2">&amp;</span>array, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(fft2_result.dtype(), Dtype::Complex64);
<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
    complex64::new(<span class="number">4.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
];
<span class="macro">assert_eq!</span>(fft2_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>ifft2_result = ifft2(<span class="kw-2">&amp;</span>fft2_result, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(ifft2_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
   complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>),
   complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>),
];
<span class="macro">assert_eq!</span>(ifft2_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>rfft2_result = rfft2(<span class="kw-2">&amp;</span>array, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(rfft2_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = <span class="kw-2">&amp;</span>[
    complex64::new(<span class="number">4.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
    complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>),
];
<span class="macro">assert_eq!</span>(rfft2_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>irfft2_result = irfft2(<span class="kw-2">&amp;</span>rfft2_result, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(irfft2_result.dtype(), Dtype::Float32);
<span class="macro">assert_eq!</span>(irfft2_result.as_slice::&lt;f32&gt;(), <span class="kw-2">&amp;</span>src[..]);

<span class="comment">// The original array is not modified
</span><span class="kw">let </span>data: <span class="kw-2">&amp;</span>[f32] = array.as_slice();
<span class="macro">assert_eq!</span>(data, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]);</code></pre></div>
<h3 id="n-dimensions"><a class="doc-anchor" href="#n-dimensions">§</a><code>N</code> dimensions</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>mlx_rs::{Dtype, Array, StreamOrDevice, complex64, fft::<span class="kw-2">*</span>};

<span class="kw">let </span><span class="kw-2">mut </span>array = Array::ones::&lt;f32&gt;(<span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>fftn_result = fftn(<span class="kw-2">&amp;</span>array, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(fftn_result.dtype(), Dtype::Complex64);

<span class="kw">let </span><span class="kw-2">mut </span>expected = [complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>); <span class="number">8</span>];
expected[<span class="number">0</span>] = complex64::new(<span class="number">8.0</span>, <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(fftn_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>ifftn_result = ifftn(<span class="kw-2">&amp;</span>fftn_result, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(ifftn_result.dtype(), Dtype::Complex64);

<span class="kw">let </span>expected = [complex64::new(<span class="number">1.0</span>, <span class="number">0.0</span>); <span class="number">8</span>];
<span class="macro">assert_eq!</span>(ifftn_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>rfftn_result = rfftn(<span class="kw-2">&amp;</span>array, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(rfftn_result.dtype(), Dtype::Complex64);

<span class="kw">let </span><span class="kw-2">mut </span>expected = [complex64::new(<span class="number">0.0</span>, <span class="number">0.0</span>); <span class="number">8</span>];
expected[<span class="number">0</span>] = complex64::new(<span class="number">8.0</span>, <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(rfftn_result.as_slice::&lt;complex64&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="kw">let </span><span class="kw-2">mut </span>irfftn_result = irfftn(<span class="kw-2">&amp;</span>rfftn_result, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>).unwrap();
<span class="macro">assert_eq!</span>(irfftn_result.dtype(), Dtype::Float32);

<span class="kw">let </span>expected = [<span class="number">1.0</span>; <span class="number">8</span>];
<span class="macro">assert_eq!</span>(irfftn_result.as_slice::&lt;f32&gt;(), <span class="kw-2">&amp;</span>expected[..]);

<span class="comment">// The original array is not modified
</span><span class="kw">let </span>data: <span class="kw-2">&amp;</span>[f32] = array.as_slice();
<span class="macro">assert_eq!</span>(data, <span class="kw-2">&amp;</span>[<span class="number">1.0</span>; <span class="number">8</span>]);</code></pre></div>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.fft.html" title="fn mlx_rs::fft::fft">fft</a></div><div class="desc docblock-short">One dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.fft2.html" title="fn mlx_rs::fft::fft2">fft2</a></div><div class="desc docblock-short">Two dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.fft2_device.html" title="fn mlx_rs::fft::fft2_device">fft2_device</a></div><div class="desc docblock-short">Two dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.fft_device.html" title="fn mlx_rs::fft::fft_device">fft_device</a></div><div class="desc docblock-short">One dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.fftn.html" title="fn mlx_rs::fft::fftn">fftn</a></div><div class="desc docblock-short">n-dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.fftn_device.html" title="fn mlx_rs::fft::fftn_device">fftn_device</a></div><div class="desc docblock-short">n-dimensional discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifft.html" title="fn mlx_rs::fft::ifft">ifft</a></div><div class="desc docblock-short">One dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifft2.html" title="fn mlx_rs::fft::ifft2">ifft2</a></div><div class="desc docblock-short">Two dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifft2_device.html" title="fn mlx_rs::fft::ifft2_device">ifft2_device</a></div><div class="desc docblock-short">Two dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifft_device.html" title="fn mlx_rs::fft::ifft_device">ifft_device</a></div><div class="desc docblock-short">One dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifftn.html" title="fn mlx_rs::fft::ifftn">ifftn</a></div><div class="desc docblock-short">n-dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.ifftn_device.html" title="fn mlx_rs::fft::ifftn_device">ifftn_device</a></div><div class="desc docblock-short">n-dimensional inverse discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.irfft.html" title="fn mlx_rs::fft::irfft">irfft</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfft.html" title="fn mlx_rs::fft::rfft"><code>rfft()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.irfft2.html" title="fn mlx_rs::fft::irfft2">irfft2</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfft2.html" title="fn mlx_rs::fft::rfft2"><code>rfft2()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.irfft2_device.html" title="fn mlx_rs::fft::irfft2_device">irfft2_device</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfft2.html" title="fn mlx_rs::fft::rfft2"><code>rfft2()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.irfft_device.html" title="fn mlx_rs::fft::irfft_device">irfft_device</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfft.html" title="fn mlx_rs::fft::rfft"><code>rfft()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.irfftn.html" title="fn mlx_rs::fft::irfftn">irfftn</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfftn.html" title="fn mlx_rs::fft::rfftn"><code>rfftn()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.irfftn_device.html" title="fn mlx_rs::fft::irfftn_device">irfftn_device</a></div><div class="desc docblock-short">The inverse of <a href="fn.rfftn.html" title="fn mlx_rs::fft::rfftn"><code>rfftn()</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.rfft.html" title="fn mlx_rs::fft::rfft">rfft</a></div><div class="desc docblock-short">One dimensional discrete Fourier Transform on a real input.</div></li><li><div class="item-name"><a class="fn" href="fn.rfft2.html" title="fn mlx_rs::fft::rfft2">rfft2</a></div><div class="desc docblock-short">Two dimensional real discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rfft2_device.html" title="fn mlx_rs::fft::rfft2_device">rfft2_device</a></div><div class="desc docblock-short">Two dimensional real discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rfft_device.html" title="fn mlx_rs::fft::rfft_device">rfft_device</a></div><div class="desc docblock-short">One dimensional discrete Fourier Transform on a real input.</div></li><li><div class="item-name"><a class="fn" href="fn.rfftn.html" title="fn mlx_rs::fft::rfftn">rfftn</a></div><div class="desc docblock-short">n-dimensional real discrete Fourier Transform.</div></li><li><div class="item-name"><a class="fn" href="fn.rfftn_device.html" title="fn mlx_rs::fft::rfftn_device">rfftn_device</a></div><div class="desc docblock-short">n-dimensional real discrete Fourier Transform.</div></li></ul></section></div></main></body></html>