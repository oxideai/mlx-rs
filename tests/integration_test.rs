// Integration tests comparing results vs known results from python
// This file is @generated by tools/generate_integration_tests.py

use mlx_rs::{
    fft::{
        fft2_device, fft_device, fftn_device, ifft2_device, ifft_device, ifftn_device,
        irfft2_device, irfft_device, irfftn_device, rfft2_device, rfft_device, rfftn_device,
    },
    Array, Dtype, StreamOrDevice,
};
use num_complex::Complex32;
use num_traits::Pow;
use pretty_assertions::assert_eq;
use std::ops::{Add, Div, Mul, Rem, Sub};

#[test]
fn test_add_op() {
    mlx_rs::random::seed(864);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a + &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sub_op() {
    mlx_rs::random::seed(394);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a - &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mul_op() {
    mlx_rs::random::seed(776);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a * &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_div_op() {
    mlx_rs::random::seed(911);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a / &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mod_op() {
    mlx_rs::random::seed(430);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a % &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_pow_op() {
    mlx_rs::random::seed(41);
    let a = Array::from_slice(
        &[
            0.22150959074497223,
            1.8410156965255737,
            1.548897385597229,
            0.7334198355674744,
            0.441251665353775,
            0.5487037301063538,
            0.7351315021514893,
            0.4545445740222931,
            1.5514036417007446,
            1.5093823671340942,
            0.6182904243469238,
            0.31907644867897034,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = Array::from_slice(
        &[
            1.5800622701644897,
            1.7776278257369995,
            0.5302109718322754,
            1.54470694065094,
            0.861287534236908,
            0.5307390689849854,
            1.6360782384872437,
            0.3754667341709137,
            0.6899919509887695,
            0.977148711681366,
            1.952046275138855,
            0.8902877569198608,
        ],
        &[4, 3],
    );
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_pow_op1() {
    mlx_rs::random::seed(265);
    let a = Array::from_slice(
        &[
            0.9202654957771301,
            0.6680494546890259,
            0.4415310323238373,
            0.9130102396011353,
            1.0048154592514038,
            1.9913296699523926,
            1.3810899257659912,
            1.1833419799804688,
            1.9574943780899048,
            1.3276519775390625,
            0.29155462980270386,
            0.8251072764396667,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_equal_op() {
    mlx_rs::random::seed(988);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_equal_op1() {
    mlx_rs::random::seed(523);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_not_equal_op() {
    mlx_rs::random::seed(497);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_not_equal_op1() {
    mlx_rs::random::seed(414);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op() {
    mlx_rs::random::seed(940);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op1() {
    mlx_rs::random::seed(802);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op() {
    mlx_rs::random::seed(849);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op1() {
    mlx_rs::random::seed(310);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op() {
    mlx_rs::random::seed(991);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op1() {
    mlx_rs::random::seed(488);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_greater_than_equal_op() {
    mlx_rs::random::seed(366);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_equal_op1() {
    mlx_rs::random::seed(597);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_abs() {
    mlx_rs::random::seed(913);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.abs();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_all() {
    mlx_rs::random::seed(929);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(None, None).unwrap();
    assert_eq!(result.shape().is_empty(), true);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all1() {
    mlx_rs::random::seed(223);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(&[-1][..], None).unwrap();
    assert_eq!(result.shape(), &[4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all2() {
    mlx_rs::random::seed(516);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[2, 3, 4, 3], None).unwrap();
    assert_eq!(a.shape(), &[2, 3, 4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(&[0, -1][..], None).unwrap();
    assert_eq!(result.shape(), &[3, 4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_floor() {
    mlx_rs::random::seed(142);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.floor().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log() {
    mlx_rs::random::seed(288);
    let a = Array::from_slice(
        &[
            0.47269025444984436,
            1.957660436630249,
            0.7257681488990784,
            1.8896647691726685,
            0.13170140981674194,
            1.9257241487503052,
            0.6978443264961243,
            0.3046002686023712,
            0.9792980551719666,
            0.25275877118110657,
            1.2376878261566162,
            0.30634790658950806,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log2() {
    mlx_rs::random::seed(143);
    let a = Array::from_slice(
        &[
            1.3399080038070679,
            0.8390129804611206,
            1.3553991317749023,
            1.4252506494522095,
            1.3026633262634277,
            1.6815094947814941,
            0.44251570105552673,
            0.45319145917892456,
            1.0023398399353027,
            0.5834028124809265,
            1.0060535669326782,
            1.001531958580017,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log2();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log10() {
    mlx_rs::random::seed(773);
    let a = Array::from_slice(
        &[
            0.9140231609344482,
            0.46055954694747925,
            1.3730783462524414,
            0.778434693813324,
            0.8405736088752747,
            1.1985399723052979,
            1.7540160417556763,
            0.24585458636283875,
            0.6850132942199707,
            1.8687775135040283,
            0.4515070915222168,
            0.4215632677078247,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log10();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log1p() {
    mlx_rs::random::seed(97);
    let a = Array::from_slice(
        &[
            0.12038002163171768,
            1.647945761680603,
            0.23794081807136536,
            1.7502785921096802,
            0.5283485651016235,
            1.4420909881591797,
            0.4129406809806824,
            1.689857006072998,
            1.0602513551712036,
            1.7814853191375732,
            1.7983895540237427,
            0.36280056834220886,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log1p();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_reciprocal() {
    mlx_rs::random::seed(633);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.reciprocal();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_round() {
    mlx_rs::random::seed(818);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.round(None);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sin() {
    mlx_rs::random::seed(256);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.sin();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_cos() {
    mlx_rs::random::seed(931);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.cos();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sqrt() {
    mlx_rs::random::seed(545);
    let a = Array::from_slice(
        &[
            1.9568428993225098,
            0.685381293296814,
            0.6587623357772827,
            0.860242486000061,
            1.7169793844223022,
            0.6948739290237427,
            1.822189450263977,
            0.5336028337478638,
            0.3627924621105194,
            1.6352756023406982,
            0.5411571264266968,
            0.911626398563385,
        ],
        &[4, 3],
    );
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.sqrt();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_logical_not() {
    mlx_rs::random::seed(722);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.logical_not();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_negative() {
    mlx_rs::random::seed(829);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.negative().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_add() {
    mlx_rs::random::seed(616);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.add(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_div() {
    mlx_rs::random::seed(923);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.div(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_eq() {
    mlx_rs::random::seed(150);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_gt() {
    mlx_rs::random::seed(317);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_ge() {
    mlx_rs::random::seed(101);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_lt() {
    mlx_rs::random::seed(747);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_le() {
    mlx_rs::random::seed(75);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_matmul() {
    mlx_rs::random::seed(920);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[10, 8], None).unwrap();
    assert_eq!(a.shape(), &[10, 8]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 13], None).unwrap();
    assert_eq!(b.shape(), &[8, 13]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.matmul(&b).unwrap();
    assert_eq!(result.shape(), &[10, 13]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mul() {
    mlx_rs::random::seed(870);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.mul(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_ne() {
    mlx_rs::random::seed(700);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_rem() {
    mlx_rs::random::seed(338);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.rem(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sub() {
    mlx_rs::random::seed(483);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.sub(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_() {
    mlx_rs::random::seed(573);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_1() {
    mlx_rs::random::seed(103);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_2() {
    mlx_rs::random::seed(362);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_3() {
    mlx_rs::random::seed(444);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_() {
    mlx_rs::random::seed(323);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_1() {
    mlx_rs::random::seed(625);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_2() {
    mlx_rs::random::seed(655);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_3() {
    mlx_rs::random::seed(934);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_() {
    mlx_rs::random::seed(209);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_1() {
    mlx_rs::random::seed(989);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[41]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[41]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_2() {
    mlx_rs::random::seed(565);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[61]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[61]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_3() {
    mlx_rs::random::seed(488);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_() {
    mlx_rs::random::seed(453);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_1() {
    mlx_rs::random::seed(886);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[80]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_2() {
    mlx_rs::random::seed(533);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[120]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_3() {
    mlx_rs::random::seed(266);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_() {
    mlx_rs::random::seed(63);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_1() {
    mlx_rs::random::seed(824);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_2() {
    mlx_rs::random::seed(940);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_3() {
    mlx_rs::random::seed(561);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_() {
    mlx_rs::random::seed(937);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_1() {
    mlx_rs::random::seed(14);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_2() {
    mlx_rs::random::seed(95);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_3() {
    mlx_rs::random::seed(736);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_() {
    mlx_rs::random::seed(860);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_1() {
    mlx_rs::random::seed(408);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_2() {
    mlx_rs::random::seed(727);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_3() {
    mlx_rs::random::seed(844);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_() {
    mlx_rs::random::seed(803);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_1() {
    mlx_rs::random::seed(684);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_2() {
    mlx_rs::random::seed(640);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_3() {
    mlx_rs::random::seed(1);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_() {
    mlx_rs::random::seed(626);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_1() {
    mlx_rs::random::seed(505);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_2() {
    mlx_rs::random::seed(847);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_3() {
    mlx_rs::random::seed(888);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_() {
    mlx_rs::random::seed(341);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_1() {
    mlx_rs::random::seed(249);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_2() {
    mlx_rs::random::seed(747);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_3() {
    mlx_rs::random::seed(333);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_() {
    mlx_rs::random::seed(720);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_1() {
    mlx_rs::random::seed(891);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_2() {
    mlx_rs::random::seed(64);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_3() {
    mlx_rs::random::seed(195);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_() {
    mlx_rs::random::seed(939);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_1() {
    mlx_rs::random::seed(581);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_2() {
    mlx_rs::random::seed(227);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_3() {
    mlx_rs::random::seed(244);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
}
