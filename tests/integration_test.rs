// Integration tests comparing results vs known results from python
// This file is @generated by tools/generate_integration_tests.py

use mlx_rs::{
    fft::{
        fft2_device, fft_device, fftn_device, ifft2_device, ifft_device, ifftn_device,
        irfft2_device, irfft_device, irfftn_device, rfft2_device, rfft_device, rfftn_device,
    },
    Array, Dtype, StreamOrDevice,
};
use num_complex::Complex32;
use num_traits::Pow;
use pretty_assertions::assert_eq;
use std::ops::{Add, Div, Mul, Rem, Sub};

#[test]
fn test_add_op() {
    mlx_rs::random::seed(864);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a + &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sub_op() {
    mlx_rs::random::seed(394);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a - &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mul_op() {
    mlx_rs::random::seed(776);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a * &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_div_op() {
    mlx_rs::random::seed(911);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a / &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mod_op() {
    mlx_rs::random::seed(430);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = &a % &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_pow_op() {
    mlx_rs::random::seed(41);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_pow_op1() {
    mlx_rs::random::seed(265);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_equal_op() {
    mlx_rs::random::seed(988);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_equal_op1() {
    mlx_rs::random::seed(523);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_not_equal_op() {
    mlx_rs::random::seed(497);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_not_equal_op1() {
    mlx_rs::random::seed(414);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op() {
    mlx_rs::random::seed(940);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op1() {
    mlx_rs::random::seed(802);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op() {
    mlx_rs::random::seed(849);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op1() {
    mlx_rs::random::seed(310);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op() {
    mlx_rs::random::seed(991);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op1() {
    mlx_rs::random::seed(488);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_greater_than_equal_op() {
    mlx_rs::random::seed(366);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_equal_op1() {
    mlx_rs::random::seed(597);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b: Array = 1.3.into();
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_abs() {
    mlx_rs::random::seed(913);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.abs();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_all() {
    mlx_rs::random::seed(929);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(None, None).unwrap();
    assert_eq!(result.shape().is_empty(), true);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all1() {
    mlx_rs::random::seed(223);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(&[-1][..], None).unwrap();
    assert_eq!(result.shape(), &[4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all2() {
    mlx_rs::random::seed(516);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[2, 3, 4, 3], None).unwrap();
    assert_eq!(a.shape(), &[2, 3, 4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.all(&[0, -1][..], None).unwrap();
    assert_eq!(result.shape(), &[3, 4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_floor() {
    mlx_rs::random::seed(142);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.floor().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log() {
    mlx_rs::random::seed(288);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log2() {
    mlx_rs::random::seed(143);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log2();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log10() {
    mlx_rs::random::seed(773);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log10();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_log1p() {
    mlx_rs::random::seed(97);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.log1p();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_reciprocal() {
    mlx_rs::random::seed(633);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.reciprocal();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_round() {
    mlx_rs::random::seed(818);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.round(None);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sin() {
    mlx_rs::random::seed(256);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.sin();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_cos() {
    mlx_rs::random::seed(931);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.cos();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sqrt() {
    mlx_rs::random::seed(545);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.sqrt();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_logical_not() {
    mlx_rs::random::seed(722);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.logical_not();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_negative() {
    mlx_rs::random::seed(829);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let result = a.negative().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_add() {
    mlx_rs::random::seed(616);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.add(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_div() {
    mlx_rs::random::seed(923);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.div(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_eq() {
    mlx_rs::random::seed(150);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_gt() {
    mlx_rs::random::seed(317);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_ge() {
    mlx_rs::random::seed(101);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_lt() {
    mlx_rs::random::seed(747);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_le() {
    mlx_rs::random::seed(75);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_matmul() {
    mlx_rs::random::seed(920);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[10, 8], None).unwrap();
    assert_eq!(a.shape(), &[10, 8]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 13], None).unwrap();
    assert_eq!(b.shape(), &[8, 13]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.matmul(&b).unwrap();
    assert_eq!(result.shape(), &[10, 13]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_mul() {
    mlx_rs::random::seed(870);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.mul(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_ne() {
    mlx_rs::random::seed(700);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_rem() {
    mlx_rs::random::seed(338);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.rem(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_sub() {
    mlx_rs::random::seed(483);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    let result = a.sub(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_() {
    mlx_rs::random::seed(573);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_1() {
    mlx_rs::random::seed(103);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_2() {
    mlx_rs::random::seed(362);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft_3() {
    mlx_rs::random::seed(444);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_() {
    mlx_rs::random::seed(323);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_1() {
    mlx_rs::random::seed(625);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_2() {
    mlx_rs::random::seed(655);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft_3() {
    mlx_rs::random::seed(934);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_() {
    mlx_rs::random::seed(209);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_1() {
    mlx_rs::random::seed(989);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[41]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[41]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_2() {
    mlx_rs::random::seed(565);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[61]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[61]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft_3() {
    mlx_rs::random::seed(488);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_() {
    mlx_rs::random::seed(453);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_1() {
    mlx_rs::random::seed(886);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[80]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_2() {
    mlx_rs::random::seed(533);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[120]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft_3() {
    mlx_rs::random::seed(266);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_() {
    mlx_rs::random::seed(63);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_1() {
    mlx_rs::random::seed(824);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_2() {
    mlx_rs::random::seed(940);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fft2_3() {
    mlx_rs::random::seed(561);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_() {
    mlx_rs::random::seed(937);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_1() {
    mlx_rs::random::seed(14);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_2() {
    mlx_rs::random::seed(95);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifft2_3() {
    mlx_rs::random::seed(736);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_() {
    mlx_rs::random::seed(860);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_1() {
    mlx_rs::random::seed(408);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_2() {
    mlx_rs::random::seed(727);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_fftn_3() {
    mlx_rs::random::seed(844);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_() {
    mlx_rs::random::seed(803);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_1() {
    mlx_rs::random::seed(684);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_2() {
    mlx_rs::random::seed(640);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_ifftn_3() {
    mlx_rs::random::seed(1);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_() {
    mlx_rs::random::seed(626);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_1() {
    mlx_rs::random::seed(505);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_2() {
    mlx_rs::random::seed(847);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfft2_3() {
    mlx_rs::random::seed(888);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_() {
    mlx_rs::random::seed(341);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_1() {
    mlx_rs::random::seed(249);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_2() {
    mlx_rs::random::seed(747);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfft2_3() {
    mlx_rs::random::seed(333);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_() {
    mlx_rs::random::seed(720);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_1() {
    mlx_rs::random::seed(891);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_2() {
    mlx_rs::random::seed(64);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_rfftn_3() {
    mlx_rs::random::seed(195);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_() {
    mlx_rs::random::seed(939);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_1() {
    mlx_rs::random::seed(581);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_2() {
    mlx_rs::random::seed(227);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
}

#[test]
fn test_irfftn_3() {
    mlx_rs::random::seed(244);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
}
