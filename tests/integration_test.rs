// Integration tests comparing results vs known results from python
// This file is @generated by tools/generate_integration_tests.py

use float_eq::float_eq;
use mlx_rs::{
    fft::{
        fft2_device, fft_device, fftn_device, ifft2_device, ifft_device, ifftn_device,
        irfft2_device, irfft_device, irfftn_device, rfft2_device, rfft_device, rfftn_device,
    },
    Array, Dtype, StreamOrDevice,
};
use num_complex::Complex32;
use num_traits::Pow;
use pretty_assertions::assert_eq;
use std::ops::{Add, Div, Mul, Rem, Sub};

#[test]
fn test_add_op() {
    mlx_rs::random::seed(864);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.32840442657470703,
        abs <= 0.006568088531494141
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        3.9408528804779053,
        abs <= 0.07881705760955811
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.38708561658859253,
        abs <= -0.007741712331771851
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -4.645027160644531,
        abs <= -0.09290054321289062
    );
    let result = &a + &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.05868121236562729,
        abs <= -0.0011736242473125457
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -0.7041745185852051,
        abs <= -0.014083490371704102
    );
}

#[test]
fn test_sub_op() {
    mlx_rs::random::seed(394);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.17949937283992767,
        abs <= -0.0035899874567985536
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -2.1539924144744873,
        abs <= -0.04307984828948975
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.12489726394414902,
        abs <= 0.00249794527888298
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        1.4987671375274658,
        abs <= 0.029975342750549316
    );
    let result = &a - &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.3043966293334961,
        abs <= -0.006087932586669922
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -3.652759552001953,
        abs <= -0.07305519104003906
    );
}

#[test]
fn test_mul_op() {
    mlx_rs::random::seed(776);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.1590166687965393,
        abs <= 0.003180333375930786
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        1.9082000255584717,
        abs <= 0.03816400051116944
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.7189191579818726,
        abs <= 0.01437838315963745
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        8.627029418945312,
        abs <= 0.17254058837890626
    );
    let result = &a * &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.40629419684410095,
        abs <= 0.008125883936882019
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        4.875530242919922,
        abs <= 0.09751060485839844
    );
}

#[test]
fn test_div_op() {
    mlx_rs::random::seed(911);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.523838222026825,
        abs <= 0.0104767644405365
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        6.28605842590332,
        abs <= 0.12572116851806642
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.28246065974235535,
        abs <= 0.005649213194847107
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        3.3895277976989746,
        abs <= 0.0677905559539795
    );
    let result = &a / &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -3.5618350505828857,
        abs <= -0.07123670101165772
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -42.74201965332031,
        abs <= -0.8548403930664062
    );
}

#[test]
fn test_mod_op() {
    mlx_rs::random::seed(430);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.05095359683036804,
        abs <= 0.0010190719366073608
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.6114431619644165,
        abs <= 0.01222886323928833
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.13153076171875,
        abs <= 0.002630615234375
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        1.5783690214157104,
        abs <= 0.03156738042831421
    );
    let result = &a % &b;
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.046716686338186264,
        abs <= 0.0009343337267637253
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.560600221157074,
        abs <= 0.01121200442314148
    );
}

#[test]
fn test_pow_op() {
    mlx_rs::random::seed(41);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.8768855929374695,
        abs <= 0.01753771185874939
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        10.522626876831055,
        abs <= 0.2104525375366211
    );
    let b = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        1.112137794494629,
        abs <= 0.02224275588989258
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        13.345653533935547,
        abs <= 0.26691307067871095
    );
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.9253264665603638,
        abs <= 0.018506529331207274
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        11.103917121887207,
        abs <= 0.22207834243774416
    );
}

#[test]
fn test_pow_op1() {
    mlx_rs::random::seed(265);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        1.0754368305206299,
        abs <= 0.0215087366104126
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        12.905241966247559,
        abs <= 0.25810483932495115
    );
    let b: Array = 1.3.into();
    let result = a.pow(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        1.1470472812652588,
        abs <= 0.022940945625305176
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        13.764567375183105,
        abs <= 0.27529134750366213
    );
}

#[test]
fn test_equal_op() {
    mlx_rs::random::seed(988);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.03418738767504692,
        abs <= 0.0006837477535009385
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.41024863719940186,
        abs <= 0.008204972743988037
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.841292142868042,
        abs <= 0.01682584285736084
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        10.095505714416504,
        abs <= 0.20191011428833008
    );
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_equal_op1() {
    mlx_rs::random::seed(523);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.112852081656456,
        abs <= 0.00225704163312912
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        1.3542249202728271,
        abs <= 0.027084498405456542
    );
    let b: Array = 1.3.into();
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_not_equal_op() {
    mlx_rs::random::seed(497);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.24078607559204102,
        abs <= -0.004815721511840821
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -2.889432907104492,
        abs <= -0.057788658142089847
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.06469622254371643,
        abs <= 0.0012939244508743287
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        0.7763546705245972,
        abs <= 0.015527093410491943
    );
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_not_equal_op1() {
    mlx_rs::random::seed(414);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.12723450362682343,
        abs <= -0.0025446900725364686
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -1.5268139839172363,
        abs <= -0.030536279678344727
    );
    let b: Array = 1.3.into();
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op() {
    mlx_rs::random::seed(940);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.3181919455528259,
        abs <= -0.0063638389110565186
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -3.818303346633911,
        abs <= -0.07636606693267822
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.46333616971969604,
        abs <= 0.009266723394393921
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        5.560033798217773,
        abs <= 0.11120067596435547
    );
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_op1() {
    mlx_rs::random::seed(802);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.08001989126205444,
        abs <= 0.001600397825241089
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.9602386951446533,
        abs <= 0.019204773902893067
    );
    let b: Array = 1.3.into();
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op() {
    mlx_rs::random::seed(849);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.5959362983703613,
        abs <= -0.011918725967407227
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -7.151235103607178,
        abs <= -0.14302470207214354
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.42154282331466675,
        abs <= 0.008430856466293336
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        5.058513641357422,
        abs <= 0.10117027282714844
    );
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_less_than_equal_op1() {
    mlx_rs::random::seed(310);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.15466859936714172,
        abs <= 0.0030933719873428344
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        1.8560230731964111,
        abs <= 0.03712046146392822
    );
    let b: Array = 1.3.into();
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op() {
    mlx_rs::random::seed(991);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.34309279918670654,
        abs <= -0.006861855983734131
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -4.1171135902404785,
        abs <= -0.08234227180480957
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.22536444664001465,
        abs <= -0.004507288932800293
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -2.704373359680176,
        abs <= -0.054087467193603515
    );
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_op1() {
    mlx_rs::random::seed(488);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.398279070854187,
        abs <= -0.00796558141708374
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -4.779348850250244,
        abs <= -0.09558697700500489
    );
    let b: Array = 1.3.into();
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_greater_than_equal_op() {
    mlx_rs::random::seed(366);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.18560372292995453,
        abs <= -0.0037120744585990907
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -2.2272446155548096,
        abs <= -0.04454489231109619
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.14294207096099854,
        abs <= -0.002858841419219971
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -1.7153047323226929,
        abs <= -0.03430609464645386
    );
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_greater_than_equal_op1() {
    mlx_rs::random::seed(597);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.268618643283844,
        abs <= -0.00537237286567688
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -3.223423480987549,
        abs <= -0.06446846961975097
    );
    let b: Array = 1.3.into();
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_abs() {
    mlx_rs::random::seed(913);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.040915559977293015,
        abs <= 0.0008183111995458603
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.490986704826355,
        abs <= 0.0098197340965271
    );
    let result = a.abs();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.7385814189910889,
        abs <= 0.014771628379821778
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        8.862977027893066,
        abs <= 0.17725954055786133
    );
}

#[test]
fn test_all() {
    mlx_rs::random::seed(929);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.2947184443473816,
        abs <= -0.005894368886947632
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -3.536621332168579,
        abs <= -0.07073242664337158
    );
    let result = a.all(None, None).unwrap();
    assert_eq!(result.shape().is_empty(), true);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all1() {
    mlx_rs::random::seed(223);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.009602058678865433,
        abs <= -0.00019204117357730867
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -0.11522470414638519,
        abs <= -0.002304494082927704
    );
    let result = a.all(&[-1][..], None).unwrap();
    assert_eq!(result.shape(), &[4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_all2() {
    mlx_rs::random::seed(516);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[2, 3, 4, 3], None).unwrap();
    assert_eq!(a.shape(), &[2, 3, 4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.4954233765602112,
        abs <= 0.009908467531204224
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        35.67048263549805,
        abs <= 0.7134096527099609
    );
    let result = a.all(&[0, -1][..], None).unwrap();
    assert_eq!(result.shape(), &[3, 4]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_floor() {
    mlx_rs::random::seed(142);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.21625718474388123,
        abs <= 0.004325143694877624
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        2.595086097717285,
        abs <= 0.051901721954345705
    );
    let result = a.floor().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.3333333432674408,
        abs <= -0.006666666865348816
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -4.0,
        abs <= -0.08
    );
}

#[test]
fn test_log() {
    mlx_rs::random::seed(288);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.9068121910095215,
        abs <= 0.01813624382019043
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        10.881746292114258,
        abs <= 0.21763492584228517
    );
    let result = a.log();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.420678973197937,
        abs <= -0.00841357946395874
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -5.048147678375244,
        abs <= -0.10096295356750488
    );
}

#[test]
fn test_log2() {
    mlx_rs::random::seed(143);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        1.0360649824142456,
        abs <= 0.020721299648284914
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        12.432779312133789,
        abs <= 0.24865558624267578
    );
    let result = a.log2();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.06925849616527557,
        abs <= -0.0013851699233055116
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -0.8311018943786621,
        abs <= -0.016622037887573243
    );
}

#[test]
fn test_log10() {
    mlx_rs::random::seed(773);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.9159950613975525,
        abs <= 0.01831990122795105
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        10.99194049835205,
        abs <= 0.21983880996704103
    );
    let result = a.log10();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.11017629504203796,
        abs <= -0.002203525900840759
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -1.3221155405044556,
        abs <= -0.02644231081008911
    );
}

#[test]
fn test_log1p() {
    mlx_rs::random::seed(97);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        1.069392442703247,
        abs <= 0.02138784885406494
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        12.832709312438965,
        abs <= 0.2566541862487793
    );
    let result = a.log1p();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.6707672476768494,
        abs <= 0.013415344953536988
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        8.049206733703613,
        abs <= 0.16098413467407227
    );
}

#[test]
fn test_reciprocal() {
    mlx_rs::random::seed(633);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.17345473170280457,
        abs <= 0.0034690946340560913
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        2.0814566612243652,
        abs <= 0.0416291332244873
    );
    let result = a.reciprocal();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.442837655544281,
        abs <= -0.00885675311088562
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -5.314051628112793,
        abs <= -0.10628103256225586
    );
}

#[test]
fn test_round() {
    mlx_rs::random::seed(818);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.01743374764919281,
        abs <= -0.0003486749529838562
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -0.20920497179031372,
        abs <= -0.004184099435806275
    );
    let result = a.round(None);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.0833333358168602,
        abs <= 0.001666666716337204
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        1.0,
        abs <= 0.02
    );
}

#[test]
fn test_sin() {
    mlx_rs::random::seed(256);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.15743832290172577,
        abs <= -0.0031487664580345156
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -1.8892598152160645,
        abs <= -0.03778519630432129
    );
    let result = a.sin();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.20018330216407776,
        abs <= -0.004003666043281555
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -2.4021995067596436,
        abs <= -0.04804399013519287
    );
}

#[test]
fn test_cos() {
    mlx_rs::random::seed(931);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.22450898587703705,
        abs <= -0.004490179717540741
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -2.6941077709198,
        abs <= -0.053882155418396
    );
    let result = a.cos();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.6940907835960388,
        abs <= 0.013881815671920776
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        8.329089164733887,
        abs <= 0.16658178329467774
    );
}

#[test]
fn test_sqrt() {
    mlx_rs::random::seed(545);
    let a = mlx_rs::random::uniform::<_, f32>(0.1f32, 2.0f32, &[4, 3], None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        1.0316438674926758,
        abs <= 0.020632877349853515
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        12.37972640991211,
        abs <= 0.24759452819824218
    );
    let result = a.sqrt();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.9801419973373413,
        abs <= 0.019602839946746827
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        11.761703491210938,
        abs <= 0.23523406982421877
    );
}

#[test]
fn test_logical_not() {
    mlx_rs::random::seed(722);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.01978858932852745,
        abs <= -0.00039577178657054904
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -0.2374630719423294,
        abs <= -0.004749261438846588
    );
    let result = a.logical_not();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_negative() {
    mlx_rs::random::seed(829);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.03525291010737419,
        abs <= 0.0007050582021474838
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.4230349063873291,
        abs <= 0.008460698127746582
    );
    let result = a.negative().unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.03525291010737419,
        abs <= -0.0007050582021474838
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -0.4230349063873291,
        abs <= -0.008460698127746582
    );
}

#[test]
fn test_add() {
    mlx_rs::random::seed(616);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.1122930571436882,
        abs <= 0.002245861142873764
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        1.347516655921936,
        abs <= 0.02695033311843872
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.305597722530365,
        abs <= 0.0061119544506073
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        3.66717267036438,
        abs <= 0.0733434534072876
    );
    let result = a.add(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.4178907573223114,
        abs <= 0.008357815146446228
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        5.014688968658447,
        abs <= 0.10029377937316895
    );
}

#[test]
fn test_div() {
    mlx_rs::random::seed(923);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.15595385432243347,
        abs <= -0.0031190770864486695
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -1.871446132659912,
        abs <= -0.03742892265319824
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.17053499817848206,
        abs <= 0.0034106999635696413
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        2.046419858932495,
        abs <= 0.040928397178649906
    );
    let result = a.div(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        1.9432785511016846,
        abs <= 0.03886557102203369
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        23.3193416595459,
        abs <= 0.466386833190918
    );
}

#[test]
fn test_eq() {
    mlx_rs::random::seed(150);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.02183736488223076,
        abs <= -0.0004367472976446152
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -0.2620483636856079,
        abs <= -0.005240967273712158
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.04139445349574089,
        abs <= 0.0008278890699148178
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        0.4967334270477295,
        abs <= 0.00993466854095459
    );
    let result = a.eq(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), false);
}

#[test]
fn test_gt() {
    mlx_rs::random::seed(317);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.1289883852005005,
        abs <= -0.0025797677040100097
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -1.5478605031967163,
        abs <= -0.030957210063934325
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.5541751980781555,
        abs <= -0.01108350396156311
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -6.650102138519287,
        abs <= -0.13300204277038574
    );
    let result = a.gt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_ge() {
    mlx_rs::random::seed(101);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.08150328695774078,
        abs <= -0.0016300657391548157
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -0.9780394434928894,
        abs <= -0.01956078886985779
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.32622432708740234,
        abs <= -0.006524486541748047
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -3.914691925048828,
        abs <= -0.07829383850097657
    );
    let result = a.ge(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_lt() {
    mlx_rs::random::seed(747);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.23745165765285492,
        abs <= 0.004749033153057099
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        2.8494198322296143,
        abs <= 0.056988396644592286
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.009038388729095459,
        abs <= -0.0001807677745819092
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -0.10846066474914551,
        abs <= -0.00216921329498291
    );
    let result = a.lt(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_le() {
    mlx_rs::random::seed(75);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.3039236068725586,
        abs <= -0.006078472137451172
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -3.647083282470703,
        abs <= -0.07294166564941407
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.24271723628044128,
        abs <= -0.004854344725608826
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -2.912606716156006,
        abs <= -0.05825213432312012
    );
    let result = a.le(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), false);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_matmul() {
    mlx_rs::random::seed(920);
    let a = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[10, 8], None).unwrap();
    assert_eq!(a.shape(), &[10, 8]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.5571629405021667,
        abs <= 0.011143258810043336
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        44.57303237915039,
        abs <= 0.8914606475830078
    );
    let b = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 13], None).unwrap();
    assert_eq!(b.shape(), &[8, 13]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        0.48261433839797974,
        abs <= 0.009652286767959595
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        50.191890716552734,
        abs <= 1.0038378143310547
    );
    let result = a.matmul(&b).unwrap();
    assert_eq!(result.shape(), &[10, 13]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        2.173865795135498,
        abs <= 0.043477315902709965
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        282.6025390625,
        abs <= 5.65205078125
    );
}

#[test]
fn test_mul() {
    mlx_rs::random::seed(870);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.32090985774993896,
        abs <= 0.006418197154998779
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        3.8509180545806885,
        abs <= 0.07701836109161377
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.0976833924651146,
        abs <= -0.0019536678493022918
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -1.1722006797790527,
        abs <= -0.023444013595581056
    );
    let result = a.mul(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.16028836369514465,
        abs <= -0.003205767273902893
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -1.9234602451324463,
        abs <= -0.03846920490264893
    );
}

#[test]
fn test_ne() {
    mlx_rs::random::seed(700);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        -0.20903855562210083,
        abs <= -0.004180771112442016
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        -2.50846266746521,
        abs <= -0.0501692533493042
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.012717477977275848,
        abs <= -0.000254349559545517
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -0.15260973572731018,
        abs <= -0.0030521947145462037
    );
    let result = a.ne(&b).unwrap();
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Bool);
    assert_eq!(result.all(None, None).unwrap().item::<bool>(), true);
    assert_eq!(result.any(None, None).unwrap().item::<bool>(), true);
}

#[test]
fn test_rem() {
    mlx_rs::random::seed(338);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.07185819745063782,
        abs <= 0.0014371639490127564
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        0.8622983694076538,
        abs <= 0.017245967388153077
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.46045729517936707,
        abs <= -0.009209145903587342
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -5.525487422943115,
        abs <= -0.1105097484588623
    );
    let result = a.rem(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        -0.20333433151245117,
        abs <= -0.004066686630249024
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        -2.440011978149414,
        abs <= -0.04880023956298828
    );
}

#[test]
fn test_sub() {
    mlx_rs::random::seed(483);
    let a = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(a.shape(), &[4, 3]);
    assert_eq!(a.dtype(), Dtype::Float32);
    float_eq!(
        a.mean(None, None).unwrap().item::<f32>(),
        0.0843842476606369,
        abs <= 0.001687684953212738
    );
    float_eq!(
        a.sum(None, None).unwrap().item::<f32>(),
        1.012610912322998,
        abs <= 0.020252218246459962
    );
    let b = mlx_rs::random::normal::<f32>(&[4, 3], None, None, None).unwrap();
    assert_eq!(b.shape(), &[4, 3]);
    assert_eq!(b.dtype(), Dtype::Float32);
    float_eq!(
        b.mean(None, None).unwrap().item::<f32>(),
        -0.48673853278160095,
        abs <= -0.00973477065563202
    );
    float_eq!(
        b.sum(None, None).unwrap().item::<f32>(),
        -5.840862274169922,
        abs <= -0.11681724548339845
    );
    let result = a.sub(&b);
    assert_eq!(result.shape(), &[4, 3]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.5711227655410767,
        abs <= 0.011422455310821533
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        6.853472709655762,
        abs <= 0.13706945419311523
    );
}

#[test]
fn test_fft_() {
    mlx_rs::random::seed(573);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49193280935287476,
        abs <= 0.009838656187057496
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        4919.328125,
        abs <= 98.3865625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5002716779708862,
        abs <= 0.010005433559417725
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        5002.716796875,
        abs <= 100.0543359375
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.49204036593437195,
        abs <= 0.00984080731868744
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        4920.40380859375,
        abs <= 98.408076171875
    );
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.48183417320251465,
        abs <= 0.009636683464050293
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4818.341796875,
        abs <= 96.3668359375
    );
}

#[test]
fn test_fft_1() {
    mlx_rs::random::seed(103);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49980759620666504,
        abs <= 0.009996151924133301
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        4998.076171875,
        abs <= 99.9615234375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.502456545829773,
        abs <= 0.010049130916595459
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        5024.5654296875,
        abs <= 100.49130859375
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.525657057762146,
        abs <= 0.01051314115524292
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        4205.25634765625,
        abs <= 84.10512695312501
    );
    assert_eq!(result_imaginary.shape(), &[100, 80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.5449963808059692,
        abs <= 0.010899927616119385
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4359.970703125,
        abs <= 87.1994140625
    );
}

#[test]
fn test_fft_2() {
    mlx_rs::random::seed(362);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5030828714370728,
        abs <= 0.010061657428741455
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        5030.82861328125,
        abs <= 100.616572265625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5047697424888611,
        abs <= 0.010095394849777221
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        5047.69775390625,
        abs <= 100.953955078125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.48604658246040344,
        abs <= 0.00972093164920807
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        5832.55908203125,
        abs <= 116.651181640625
    );
    assert_eq!(result_imaginary.shape(), &[100, 120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.49679213762283325,
        abs <= 0.009935842752456665
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        5961.505859375,
        abs <= 119.2301171875
    );
}

#[test]
fn test_fft_3() {
    mlx_rs::random::seed(444);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(r.shape(), &[100, 100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5001579523086548,
        abs <= 0.010003159046173096
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        5001.57958984375,
        abs <= 100.031591796875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100, 100], None).unwrap();
    assert_eq!(i.shape(), &[100, 100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4949095547199249,
        abs <= 0.009898191094398498
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        4949.095703125,
        abs <= 98.9819140625
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100, 100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.5385338068008423,
        abs <= 0.010770676136016845
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        5385.33837890625,
        abs <= 107.706767578125
    );
    assert_eq!(result_imaginary.shape(), &[100, 100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.45679911971092224,
        abs <= 0.009135982394218445
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4567.9912109375,
        abs <= 91.35982421875
    );
}

#[test]
fn test_ifft_() {
    mlx_rs::random::seed(323);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5185670256614685,
        abs <= 0.01037134051322937
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        51.85670471191406,
        abs <= 1.0371340942382812
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5397436618804932,
        abs <= 0.010794873237609864
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        53.974369049072266,
        abs <= 1.0794873809814454
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.00946841575205326,
        abs <= 0.0001893683150410652
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        0.9468415975570679,
        abs <= 0.018936831951141358
    );
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.000429909530794248,
        abs <= 8.59819061588496e-06
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        0.04299095273017883,
        abs <= 0.0008598190546035767
    );
}

#[test]
fn test_ifft_1() {
    mlx_rs::random::seed(625);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5344315767288208,
        abs <= 0.010688631534576417
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        53.44315719604492,
        abs <= 1.0688631439208984
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4382143020629883,
        abs <= 0.008764286041259766
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        43.82143020629883,
        abs <= 0.8764286041259766
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[80]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.00830454844981432,
        abs <= 0.0001660909689962864
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        0.6643638610839844,
        abs <= 0.013287277221679689
    );
    assert_eq!(result_imaginary.shape(), &[80]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.005878332536667585,
        abs <= 0.0001175666507333517
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        0.47026658058166504,
        abs <= 0.0094053316116333
    );
}

#[test]
fn test_ifft_2() {
    mlx_rs::random::seed(655);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4874846041202545,
        abs <= 0.00974969208240509
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        48.74846267700195,
        abs <= 0.974969253540039
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.45154982805252075,
        abs <= 0.009030996561050416
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        45.15498352050781,
        abs <= 0.9030996704101563
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[120]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.00010435631702421233,
        abs <= 2.0871263404842468e-06
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        0.012522757053375244,
        abs <= 0.0002504551410675049
    );
    assert_eq!(result_imaginary.shape(), &[120]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.00566977309063077,
        abs <= 0.00011339546181261539
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        0.6803727149963379,
        abs <= 0.013607454299926759
    );
}

#[test]
fn test_ifft_3() {
    mlx_rs::random::seed(934);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4756808280944824,
        abs <= 0.009513616561889648
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        47.568084716796875,
        abs <= 0.9513616943359375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4751310348510742,
        abs <= 0.009502620697021484
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        47.51310348510742,
        abs <= 0.9502620697021484
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[100]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.002144426107406616,
        abs <= 4.288852214813233e-05
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        0.21444261074066162,
        abs <= 0.004288852214813232
    );
    assert_eq!(result_imaginary.shape(), &[100]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.0032059226650744677,
        abs <= 6.411845330148936e-05
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        0.3205922842025757,
        abs <= 0.006411845684051514
    );
}

#[test]
fn test_rfft_() {
    mlx_rs::random::seed(209);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5249843597412109,
        abs <= 0.010499687194824218
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        52.49843978881836,
        abs <= 1.0499687957763673
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4521765112876892,
        abs <= 0.009043530225753785
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        45.2176513671875,
        abs <= 0.90435302734375
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        1.4385855197906494,
        abs <= 0.02877171039581299
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        73.36785888671875,
        abs <= 1.467357177734375
    );
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.18436123430728912,
        abs <= 0.0036872246861457823
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        9.402422904968262,
        abs <= 0.18804845809936524
    );
}

#[test]
fn test_rfft_1() {
    mlx_rs::random::seed(989);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4915032386779785,
        abs <= 0.00983006477355957
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        49.150325775146484,
        abs <= 0.9830065155029297
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5130519866943359,
        abs <= 0.010261039733886718
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        51.305198669433594,
        abs <= 1.0261039733886719
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[41]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.7166604995727539,
        abs <= 0.014333209991455079
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        29.383081436157227,
        abs <= 0.5876616287231445
    );
    assert_eq!(result_imaginary.shape(), &[41]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.027098461985588074,
        abs <= -0.0005419692397117615
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -1.111037015914917,
        abs <= -0.022220740318298342
    );
}

#[test]
fn test_rfft_2() {
    mlx_rs::random::seed(565);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5205792188644409,
        abs <= 0.010411584377288818
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        52.05792236328125,
        abs <= 1.041158447265625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5202609896659851,
        abs <= 0.010405219793319702
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        52.026100158691406,
        abs <= 1.040522003173828
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[61]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        1.1741952896118164,
        abs <= 0.023483905792236328
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        71.62591552734375,
        abs <= 1.432518310546875
    );
    assert_eq!(result_imaginary.shape(), &[61]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.3835507035255432,
        abs <= -0.007671014070510865
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -23.396595001220703,
        abs <= -0.4679319000244141
    );
}

#[test]
fn test_rfft_3() {
    mlx_rs::random::seed(488);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.45263075828552246,
        abs <= 0.009052615165710449
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        45.26307678222656,
        abs <= 0.9052615356445313
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5480838418006897,
        abs <= 0.010961676836013795
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        54.808387756347656,
        abs <= 1.096167755126953
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[51]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        1.3197729587554932,
        abs <= 0.026395459175109864
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        67.30841827392578,
        abs <= 1.3461683654785157
    );
    assert_eq!(result_imaginary.shape(), &[51]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.4907066524028778,
        abs <= 0.009814133048057557
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        25.026039123535156,
        abs <= 0.5005207824707031
    );
}

#[test]
fn test_irfft_() {
    mlx_rs::random::seed(453);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5243486762046814,
        abs <= 0.010486973524093628
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        52.434871673583984,
        abs <= 1.0486974334716797
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.49039560556411743,
        abs <= 0.009807912111282348
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        49.0395622253418,
        abs <= 0.980791244506836
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.004540972411632538,
        abs <= 9.081944823265076e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.8991125822067261,
        abs <= 0.01798225164413452
    );
}

#[test]
fn test_irfft_1() {
    mlx_rs::random::seed(886);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49428874254226685,
        abs <= 0.009885774850845337
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        49.42887496948242,
        abs <= 0.9885774993896485
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5252950191497803,
        abs <= 0.010505900382995606
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        52.529502868652344,
        abs <= 1.050590057373047
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 80, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[80]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.0017666377825662494,
        abs <= 3.533275565132499e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.1413310170173645,
        abs <= 0.00282662034034729
    );
}

#[test]
fn test_irfft_2() {
    mlx_rs::random::seed(533);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.48901960253715515,
        abs <= 0.009780392050743103
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        48.90196228027344,
        abs <= 0.9780392456054687
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5153160691261292,
        abs <= 0.010306321382522583
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        51.53160858154297,
        abs <= 1.0306321716308593
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, 120, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[120]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.001325542340055108,
        abs <= 2.651084680110216e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.15906506776809692,
        abs <= 0.0031813013553619388
    );
}

#[test]
fn test_irfft_3() {
    mlx_rs::random::seed(266);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(r.shape(), &[100]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5051288604736328,
        abs <= 0.010102577209472656
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        50.51288604736328,
        abs <= 1.0102577209472656
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[100], None).unwrap();
    assert_eq!(i.shape(), &[100]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5190264582633972,
        abs <= 0.010380529165267945
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        51.902645111083984,
        abs <= 1.0380529022216798
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft_device(&c, None, 0, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[198]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.0004920950159430504,
        abs <= 9.841900318861008e-06
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.09743481874465942,
        abs <= 0.0019486963748931885
    );
}

#[test]
fn test_fft2_() {
    mlx_rs::random::seed(63);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5128694772720337,
        abs <= 0.010257389545440674
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        262.58917236328125,
        abs <= 5.251783447265625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4861868619918823,
        abs <= 0.009723737239837646
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        248.92767333984375,
        abs <= 4.978553466796875
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.3187246322631836,
        abs <= 0.006374492645263672
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        163.18701171875,
        abs <= 3.263740234375
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.592434287071228,
        abs <= 0.01184868574142456
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        303.32635498046875,
        abs <= 6.066527099609375
    );
}

#[test]
fn test_fft2_1() {
    mlx_rs::random::seed(824);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.53097003698349,
        abs <= 0.0106194007396698
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        271.8566589355469,
        abs <= 5.437133178710938
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.48926323652267456,
        abs <= 0.009785264730453491
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.50277709960938,
        abs <= 5.0100555419921875
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.4241769015789032,
        abs <= 0.008483538031578064
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        40.72098159790039,
        abs <= 0.8144196319580078
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.5665144324302673,
        abs <= 0.011330288648605347
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        54.38538360595703,
        abs <= 1.0877076721191405
    );
}

#[test]
fn test_fft2_2() {
    mlx_rs::random::seed(940);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4929702877998352,
        abs <= 0.009859405755996704
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        252.40078735351562,
        abs <= 5.048015747070313
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4889233112335205,
        abs <= 0.00977846622467041
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.3287353515625,
        abs <= 5.00657470703125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.6756632924079895,
        abs <= 0.01351326584815979
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        345.9396057128906,
        abs <= 6.918792114257813
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.45924657583236694,
        abs <= 0.00918493151664734
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        235.13424682617188,
        abs <= 4.702684936523438
    );
}

#[test]
fn test_fft2_3() {
    mlx_rs::random::seed(561);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4980977773666382,
        abs <= 0.009961955547332764
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        255.02606201171875,
        abs <= 5.100521240234375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.49254220724105835,
        abs <= 0.009850844144821166
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        252.18161010742188,
        abs <= 5.043632202148437
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.32460662722587585,
        abs <= 0.006492132544517517
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        129.8426513671875,
        abs <= 2.5968530273437502
    );
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.6641926169395447,
        abs <= 0.013283852338790893
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        265.67706298828125,
        abs <= 5.313541259765625
    );
}

#[test]
fn test_ifft2_() {
    mlx_rs::random::seed(937);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.47373050451278687,
        abs <= 0.009474610090255738
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        242.55001831054688,
        abs <= 4.851000366210938
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.48451608419418335,
        abs <= 0.009690321683883667
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        248.07223510742188,
        abs <= 4.961444702148437
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.007376520894467831,
        abs <= 0.00014753041788935663
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        3.7767786979675293,
        abs <= 0.0755355739593506
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.0069538913667202,
        abs <= 0.00013907782733440399
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        3.560392379760742,
        abs <= 0.07120784759521484
    );
}

#[test]
fn test_ifft2_1() {
    mlx_rs::random::seed(14);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4912901818752289,
        abs <= 0.009825803637504578
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        251.5405731201172,
        abs <= 5.030811462402344
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5084747076034546,
        abs <= 0.010169494152069093
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        260.33905029296875,
        abs <= 5.2067810058593755
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.03991732746362686,
        abs <= 0.0007983465492725373
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        3.8320631980895996,
        abs <= 0.076641263961792
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.049577318131923676,
        abs <= 0.0009915463626384736
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4.759422302246094,
        abs <= 0.09518844604492188
    );
}

#[test]
fn test_ifft2_2() {
    mlx_rs::random::seed(95);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5085955262184143,
        abs <= 0.010171910524368286
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        260.4009094238281,
        abs <= 5.208018188476562
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5179280638694763,
        abs <= 0.010358561277389527
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        265.1791687011719,
        abs <= 5.303583374023438
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.0076621831394732,
        abs <= 0.000153243662789464
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        3.9230377674102783,
        abs <= 0.07846075534820557
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.009670466184616089,
        abs <= 0.00019340932369232177
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4.9512786865234375,
        abs <= 0.09902557373046875
    );
}

#[test]
fn test_ifft2_3() {
    mlx_rs::random::seed(736);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.48021820187568665,
        abs <= 0.009604364037513732
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        245.87171936035156,
        abs <= 4.917434387207031
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4987150728702545,
        abs <= 0.009974301457405091
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        255.3421173095703,
        abs <= 5.1068423461914065
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.010824865661561489,
        abs <= 0.00021649731323122978
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        4.329946517944336,
        abs <= 0.08659893035888672
    );
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.008488722145557404,
        abs <= 0.00016977444291114808
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        3.395488977432251,
        abs <= 0.06790977954864502
    );
}

#[test]
fn test_fftn_() {
    mlx_rs::random::seed(860);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49968665838241577,
        abs <= 0.009993733167648315
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        255.83956909179688,
        abs <= 5.116791381835937
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5132207870483398,
        abs <= 0.010264415740966797
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        262.76904296875,
        abs <= 5.255380859375
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.09350237250328064,
        abs <= 0.001870047450065613
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        47.87321472167969,
        abs <= 0.9574642944335938
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.45623522996902466,
        abs <= 0.009124704599380494
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        233.59243774414062,
        abs <= 4.671848754882813
    );
}

#[test]
fn test_fftn_1() {
    mlx_rs::random::seed(408);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49094921350479126,
        abs <= 0.009818984270095825
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        251.36599731445312,
        abs <= 5.0273199462890625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.48952794075012207,
        abs <= 0.009790558815002442
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.6383056640625,
        abs <= 5.01276611328125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.365003764629364,
        abs <= 0.00730007529258728
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        35.04035949707031,
        abs <= 0.7008071899414062
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.6621917486190796,
        abs <= 0.013243834972381591
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        63.570404052734375,
        abs <= 1.2714080810546875
    );
}

#[test]
fn test_fftn_2() {
    mlx_rs::random::seed(727);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.48969122767448425,
        abs <= 0.009793824553489686
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        250.72190856933594,
        abs <= 5.014438171386719
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.515756368637085,
        abs <= 0.010315127372741699
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        264.0672607421875,
        abs <= 5.28134521484375
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.7373149394989014,
        abs <= 0.014746298789978027
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        377.5052490234375,
        abs <= 7.55010498046875
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.4909225404262543,
        abs <= 0.009818450808525085
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        251.3523406982422,
        abs <= 5.027046813964843
    );
}

#[test]
fn test_fftn_3() {
    mlx_rs::random::seed(844);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5011866092681885,
        abs <= 0.01002373218536377
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.6075439453125,
        abs <= 5.13215087890625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.515597939491272,
        abs <= 0.010311958789825439
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        263.98614501953125,
        abs <= 5.279722900390625
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = fftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.5863966345787048,
        abs <= 0.011727932691574097
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        234.55865478515625,
        abs <= 4.6911730957031255
    );
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.5272870063781738,
        abs <= 0.010545740127563477
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        210.91481018066406,
        abs <= 4.218296203613281
    );
}

#[test]
fn test_ifftn_() {
    mlx_rs::random::seed(803);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.48484981060028076,
        abs <= 0.009696996212005616
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        248.24310302734375,
        abs <= 4.964862060546875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4952506721019745,
        abs <= 0.00990501344203949
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        253.56834411621094,
        abs <= 5.071366882324219
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.0007352348766289651,
        abs <= 1.4704697532579303e-05
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        0.37644025683403015,
        abs <= 0.007528805136680603
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.00012243445962667465,
        abs <= 2.4486891925334932e-06
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        0.06268644332885742,
        abs <= 0.0012537288665771485
    );
}

#[test]
fn test_ifftn_1() {
    mlx_rs::random::seed(684);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4867005944252014,
        abs <= 0.009734011888504028
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        249.19070434570312,
        abs <= 4.983814086914062
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.532753050327301,
        abs <= 0.010655061006546021
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        272.7695617675781,
        abs <= 5.455391235351563
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 4]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.054848313331604004,
        abs <= 0.0010969662666320801
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        5.265438079833984,
        abs <= 0.10530876159667969
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 4]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.04062918573617935,
        abs <= 0.000812583714723587
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        3.9004018306732178,
        abs <= 0.07800803661346435
    );
}

#[test]
fn test_ifftn_2() {
    mlx_rs::random::seed(640);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.482965350151062,
        abs <= 0.00965930700302124
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        247.27825927734375,
        abs <= 4.945565185546875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4901072382926941,
        abs <= 0.009802144765853883
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.93490600585938,
        abs <= 5.018698120117188
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 8]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.010085294023156166,
        abs <= 0.00020170588046312333
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        5.163670539855957,
        abs <= 0.10327341079711914
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 8]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.007911873050034046,
        abs <= 0.00015823746100068092
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        4.050879001617432,
        abs <= 0.08101758003234863
    );
}

#[test]
fn test_ifftn_3() {
    mlx_rs::random::seed(1);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5098339319229126,
        abs <= 0.010196678638458252
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        261.03497314453125,
        abs <= 5.220699462890625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.521202564239502,
        abs <= 0.010424051284790039
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        266.855712890625,
        abs <= 5.3371142578125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = ifftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 5, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.010544955730438232,
        abs <= 0.00021089911460876466
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        4.217982292175293,
        abs <= 0.08435964584350586
    );
    assert_eq!(result_imaginary.shape(), &[8, 5, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.00933288224041462,
        abs <= 0.00018665764480829238
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        3.7331531047821045,
        abs <= 0.0746630620956421
    );
}

#[test]
fn test_rfft2_() {
    mlx_rs::random::seed(626);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5090211629867554,
        abs <= 0.010180423259735108
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        260.61883544921875,
        abs <= 5.212376708984375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5061042904853821,
        abs <= 0.010122085809707642
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        259.1253967285156,
        abs <= 5.182507934570313
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.8268927931785583,
        abs <= 0.016537855863571167
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        264.6056823730469,
        abs <= 5.292113647460938
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.05014235898852348,
        abs <= -0.0010028471797704696
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -16.045555114746094,
        abs <= -0.32091110229492187
    );
}

#[test]
fn test_rfft2_1() {
    mlx_rs::random::seed(505);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4949999451637268,
        abs <= 0.009899998903274537
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        253.43997192382812,
        abs <= 5.068799438476563
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.49041298031806946,
        abs <= 0.00980825960636139
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        251.09144592285156,
        abs <= 5.0218289184570315
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.5439317226409912,
        abs <= 0.010878634452819825
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        39.163082122802734,
        abs <= 0.7832616424560547
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.12916846573352814,
        abs <= -0.002583369314670563
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -9.300128936767578,
        abs <= -0.18600257873535156
    );
}

#[test]
fn test_rfft2_2() {
    mlx_rs::random::seed(847);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5017592906951904,
        abs <= 0.01003518581390381
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.9007568359375,
        abs <= 5.13801513671875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.48960810899734497,
        abs <= 0.0097921621799469
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.67935180664062,
        abs <= 5.0135870361328125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.767216145992279,
        abs <= 0.015344322919845582
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        245.50917053222656,
        abs <= 4.910183410644532
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.03494918346405029,
        abs <= 0.0006989836692810059
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        11.183738708496094,
        abs <= 0.22367477416992188
    );
}

#[test]
fn test_rfft2_3() {
    mlx_rs::random::seed(888);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4932956099510193,
        abs <= 0.009865912199020386
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        252.56735229492188,
        abs <= 5.051347045898438
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.48510468006134033,
        abs <= 0.009702093601226806
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        248.37359619140625,
        abs <= 4.967471923828125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.593315839767456,
        abs <= 0.011866316795349122
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        142.3957977294922,
        abs <= 2.8479159545898436
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.05620301887392998,
        abs <= -0.0011240603774785997
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -13.488723754882812,
        abs <= -0.26977447509765623
    );
}

#[test]
fn test_irfft2_() {
    mlx_rs::random::seed(341);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5171229839324951,
        abs <= 0.010342459678649902
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        264.7669677734375,
        abs <= 5.29533935546875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4887220859527588,
        abs <= 0.009774441719055177
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.2257080078125,
        abs <= 5.00451416015625
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.005863568279892206,
        abs <= 0.00011727136559784412
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        5.253756999969482,
        abs <= 0.10507513999938965
    );
}

#[test]
fn test_irfft2_1() {
    mlx_rs::random::seed(249);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5012624263763428,
        abs <= 0.010025248527526856
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.6463623046875,
        abs <= 5.13292724609375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5042414665222168,
        abs <= 0.010084829330444337
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        258.171630859375,
        abs <= 5.1634326171875005
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.044041357934474945,
        abs <= 0.0008808271586894989
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        4.227970123291016,
        abs <= 0.08455940246582032
    );
}

#[test]
fn test_irfft2_2() {
    mlx_rs::random::seed(747);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5070213675498962,
        abs <= 0.010140427350997926
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        259.5949401855469,
        abs <= 5.191898803710938
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4889640808105469,
        abs <= 0.009779281616210937
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.349609375,
        abs <= 5.0069921875
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.0025466096121817827,
        abs <= 5.0932192243635656e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        2.28176212310791,
        abs <= 0.04563524246215821
    );
}

#[test]
fn test_irfft2_3() {
    mlx_rs::random::seed(333);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.4962257742881775,
        abs <= 0.00992451548576355
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        254.06759643554688,
        abs <= 5.081351928710937
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4898005723953247,
        abs <= 0.009796011447906495
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        250.77789306640625,
        abs <= 5.0155578613281255
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfft2_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.007385803386569023,
        abs <= 0.00014771606773138047
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        2.9543213844299316,
        abs <= 0.05908642768859863
    );
}

#[test]
fn test_rfftn_() {
    mlx_rs::random::seed(720);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49897629022598267,
        abs <= 0.009979525804519654
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        255.47586059570312,
        abs <= 5.109517211914063
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.49348247051239014,
        abs <= 0.009869649410247802
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        252.66302490234375,
        abs <= 5.053260498046875
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.4979190528392792,
        abs <= 0.009958381056785584
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        159.33409118652344,
        abs <= 3.186681823730469
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.1638980507850647,
        abs <= -0.003277961015701294
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -52.4473762512207,
        abs <= -1.048947525024414
    );
}

#[test]
fn test_rfftn_1() {
    mlx_rs::random::seed(891);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5014437437057495,
        abs <= 0.01002887487411499
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.73919677734375,
        abs <= 5.134783935546875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4999062418937683,
        abs <= 0.009998124837875367
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        255.95199584960938,
        abs <= 5.119039916992188
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 3]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.528995156288147,
        abs <= 0.01057990312576294
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        38.087650299072266,
        abs <= 0.7617530059814454
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 3]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.00255977688357234,
        abs <= -5.11955376714468e-05
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -0.18430393934249878,
        abs <= -0.0036860787868499756
    );
}

#[test]
fn test_rfftn_2() {
    mlx_rs::random::seed(64);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.504144012928009,
        abs <= 0.010082880258560181
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        258.1217346191406,
        abs <= 5.162434692382813
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5128475427627563,
        abs <= 0.010256950855255128
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        262.57794189453125,
        abs <= 5.2515588378906255
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 8, 5]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.6959240436553955,
        abs <= 0.013918480873107911
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        222.69569396972656,
        abs <= 4.453913879394531
    );
    assert_eq!(result_imaginary.shape(), &[8, 8, 5]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        -0.04897644743323326,
        abs <= -0.0009795289486646652
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        -15.672462463378906,
        abs <= -0.3134492492675781
    );
}

#[test]
fn test_rfftn_3() {
    mlx_rs::random::seed(195);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.49985283613204956,
        abs <= 0.009997056722640991
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        255.92465209960938,
        abs <= 5.1184930419921875
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.4984889328479767,
        abs <= 0.009969778656959534
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        255.22633361816406,
        abs <= 5.104526672363281
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = rfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    let result_real = result.as_type::<f32>();
    let result_imaginary =
        (&result / &Array::from_complex(Complex32::new(0., 1.))).as_type::<f32>();
    assert_eq!(result_real.shape(), &[8, 3, 10]);
    assert_eq!(result_real.dtype(), Dtype::Float32);
    float_eq!(
        result_real.mean(None, None).unwrap().item::<f32>(),
        0.9620382189750671,
        abs <= 0.019240764379501344
    );
    float_eq!(
        result_real.sum(None, None).unwrap().item::<f32>(),
        230.88916015625,
        abs <= 4.617783203125
    );
    assert_eq!(result_imaginary.shape(), &[8, 3, 10]);
    assert_eq!(result_imaginary.dtype(), Dtype::Float32);
    float_eq!(
        result_imaginary.mean(None, None).unwrap().item::<f32>(),
        0.010663948953151703,
        abs <= 0.00021327897906303406
    );
    float_eq!(
        result_imaginary.sum(None, None).unwrap().item::<f32>(),
        2.559347629547119,
        abs <= 0.051186952590942386
    );
}

#[test]
fn test_irfftn_() {
    mlx_rs::random::seed(939);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.500404953956604,
        abs <= 0.01000809907913208
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.20733642578125,
        abs <= 5.124146728515625
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5033134818077087,
        abs <= 0.010066269636154175
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        257.6965026855469,
        abs <= 5.153930053710938
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.0006362688727676868,
        abs <= 1.2725377455353737e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        0.5700969099998474,
        abs <= 0.011401938199996948
    );
}

#[test]
fn test_irfftn_1() {
    mlx_rs::random::seed(581);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5188198089599609,
        abs <= 0.01037639617919922
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        265.6357421875,
        abs <= 5.31271484375
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5097910165786743,
        abs <= 0.010195820331573487
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        261.01300048828125,
        abs <= 5.220260009765625
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[3, 4][..], None, StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 3, 4]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.03443935140967369,
        abs <= 0.0006887870281934739
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        3.3061776161193848,
        abs <= 0.0661235523223877
    );
}

#[test]
fn test_irfftn_2() {
    mlx_rs::random::seed(227);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.5004875659942627,
        abs <= 0.010009751319885254
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        256.2496337890625,
        abs <= 5.12499267578125
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5212831497192383,
        abs <= 0.010425662994384766
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        266.89697265625,
        abs <= 5.337939453125
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, None, &[0, 2][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 8, 14]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.004834582097828388,
        abs <= 9.669164195656776e-05
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        4.331785202026367,
        abs <= 0.08663570404052734
    );
}

#[test]
fn test_irfftn_3() {
    mlx_rs::random::seed(244);
    let r = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(r.shape(), &[8, 8, 8]);
    assert_eq!(r.dtype(), Dtype::Float32);
    float_eq!(
        r.mean(None, None).unwrap().item::<f32>(),
        0.513688862323761,
        abs <= 0.01027377724647522
    );
    float_eq!(
        r.sum(None, None).unwrap().item::<f32>(),
        263.0086975097656,
        abs <= 5.260173950195313
    );
    let i = mlx_rs::random::uniform::<_, f32>(0.0f32, 1.0f32, &[8, 8, 8], None).unwrap();
    assert_eq!(i.shape(), &[8, 8, 8]);
    assert_eq!(i.dtype(), Dtype::Float32);
    float_eq!(
        i.mean(None, None).unwrap().item::<f32>(),
        0.5022491812705994,
        abs <= 0.010044983625411988
    );
    float_eq!(
        i.sum(None, None).unwrap().item::<f32>(),
        257.1515808105469,
        abs <= 5.143031616210938
    );
    let c: Array = &(&r + &i) * &Array::from_complex(Complex32::new(0., 1.));
    assert_eq!(c.dtype(), Dtype::Complex64);
    let result = irfftn_device(&c, &[10, 5][..], &[2, 1][..], StreamOrDevice::cpu()).unwrap();
    assert_eq!(result.shape(), &[8, 5, 10]);
    assert_eq!(result.dtype(), Dtype::Float32);
    float_eq!(
        result.mean(None, None).unwrap().item::<f32>(),
        0.010228637605905533,
        abs <= 0.00020457275211811066
    );
    float_eq!(
        result.sum(None, None).unwrap().item::<f32>(),
        4.091454982757568,
        abs <= 0.08182909965515137
    );
}
